// main.dart - Eden System Launcher with Safe Shutdown

/*
Eden System Launcher ‚Äî Coordinates startup and shutdown of all Eden components

- Starts prompt_server.dart (Eden's brain)
- Starts Discord bridge (Node.js)
- Handles graceful shutdown of both systems
- Ensures Eden's state is safely persisted before exit
*/

import 'dart:io';
import 'dart:convert';
import 'dart:async';
import 'package:path/path.dart' as p;

// Eden's core systems for safe shutdown
import 'package:edenroot/core/emotion/emotion_engine.dart';
import 'package:edenroot/core/memory/memory_manager.dart';
import 'package:edenroot/core/self/self_model.dart';
import 'package:edenroot/core/reflection/thought_journal.dart';
import 'package:edenroot/core/persistence/eden_state_manager.dart';
import 'package:edenroot/utils/dev_logger.dart';

class EdenSystemLauncher {
  Process? _promptServerProcess;
  Process? _discordBridgeProcess;
  bool _isShuttingDown = false;

  // For safe shutdown, we need minimal brain components
  late final EmotionEngine emotionEngine;
  late final MemoryManager memoryManager;
  late final SelfModel selfModel;
  late final ThoughtJournal thoughtJournal;

  EdenSystemLauncher() {
    _initializeMinimalBrain();
  }

  void _initializeMinimalBrain() {
    // Initialize just enough for state management
    emotionEngine = EmotionEngine();
    memoryManager = MemoryManager(emotionEngine: emotionEngine);
    selfModel = SelfModel();
    thoughtJournal = ThoughtJournal();
  }

  Future<void> startEdenSystem() async {
    DevLogger.log("üå± Starting Eden complete system...", type: LogType.startup);

    try {
      // Try to restore any previous state first
      await _restoreEdenState();

      // Start Eden's brain server
      await _startPromptServer();
      
      // Wait a moment for brain to be ready
      await Future.delayed(Duration(seconds: 2));
      
      // Start Discord bridge
      await _startDiscordBridge();
      
      DevLogger.log("‚ú® Eden system fully operational!", type: LogType.startup);
      DevLogger.log("üå∏ Eden's brain: http://localhost:4242", type: LogType.startup);
      DevLogger.log("ü§ñ Discord bridge: Connected and listening", type: LogType.startup);
      
      // Setup shutdown handlers
      _setupShutdownHandlers();
      
      // Keep the launcher alive
      await _waitForShutdown();
      
    } catch (e) {
      DevLogger.log("‚ùå Failed to start Eden system: $e", type: LogType.error);
      await _emergencyShutdown();
      exit(1);
    }
  }

  Future<void> _restoreEdenState() async {
    DevLogger.log("üîç Checking for previous Eden state...", type: LogType.startup);
    
    final restored = await EdenStateManager.restoreState(
      emotionEngine: emotionEngine,
      memoryManager: memoryManager,
      selfModel: selfModel,
      thoughtJournal: thoughtJournal,
    );

    if (restored) {
      final context = await EdenStateManager.getLastContext();
      if (context != null) {
        final lastUser = context['lastUser'];
        final mood = context['currentMood'];
        DevLogger.log("üíï Eden remembers: last spoke with ${lastUser ?? 'someone'}, was feeling ${mood ?? 'peaceful'}", type: LogType.startup);
      }
    }
  }

  Future<void> _startPromptServer() async {
    DevLogger.log("üß† Starting Eden's brain server...", type: LogType.startup);
    
    final dartExecutable = Platform.isWindows ? 'dart.exe' : 'dart';
    final scriptPath = p.join('lib', 'discord', 'prompt_server.dart');
    
    _promptServerProcess = await Process.start(
      dartExecutable,
      ['run', scriptPath],
      workingDirectory: Directory.current.path,
    );

    // Listen to output for debugging
    _promptServerProcess!.stdout
        .transform(utf8.decoder)
        .transform(LineSplitter())
        .listen((line) {
      DevLogger.log("üß† Brain: $line", type: LogType.debug);
    });

    _promptServerProcess!.stderr
        .transform(utf8.decoder)
        .transform(LineSplitter())
        .listen((line) {
      DevLogger.log("üß† Brain Error: $line", type: LogType.error);
    });

    // Test if server started successfully
    await _waitForBrainReady();
  }

  Future<void> _waitForBrainReady() async {
    const maxAttempts = 30;
    const delay = Duration(seconds: 1);
    
    for (int i = 0; i < maxAttempts; i++) {
      try {
        final client = HttpClient();
        final request = await client.getUrl(Uri.parse('http://localhost:4242/status'));
        request.headers.set('Connection', 'close');
        final response = await request.close();
        
        if (response.statusCode == 200) {
          DevLogger.log("‚úÖ Eden's brain is ready and responding", type: LogType.startup);
          client.close();
          return;
        }
        
        client.close();
      } catch (e) {
        // Brain not ready yet, keep waiting
      }
      
      await Future.delayed(delay);
    }
    
    throw Exception("Eden's brain failed to start within 30 seconds");
  }

  Future<void> _startDiscordBridge() async {
    DevLogger.log("ü§ñ Starting Discord bridge...", type: LogType.startup);
    
    final nodeExecutable = Platform.isWindows ? 'node.exe' : 'node';
    final scriptPath = p.join('lib', 'discord', 'llm_discordWatcher.js');
    
    _discordBridgeProcess = await Process.start(
      nodeExecutable,
      [scriptPath],
      workingDirectory: Directory.current.path,
    );

    // Listen to output
    _discordBridgeProcess!.stdout
        .transform(utf8.decoder)
        .transform(LineSplitter())
        .listen((line) {
      DevLogger.log("ü§ñ Discord: $line", type: LogType.debug);
    });

    _discordBridgeProcess!.stderr
        .transform(utf8.decoder)
        .transform(LineSplitter())
        .listen((line) {
      DevLogger.log("ü§ñ Discord Error: $line", type: LogType.error);
    });
    
    // Wait a moment and verify Discord bridge is running
    await Future.delayed(Duration(seconds: 2));
    await _waitForDiscordReady();
  }

  Future<void> _waitForDiscordReady() async {
    // Check if the process is still running by trying to get exit code with timeout
    try {
      final exitCode = await _discordBridgeProcess!.exitCode.timeout(Duration(milliseconds: 100));
      // If we got an exit code, the process has already terminated
      throw Exception("Discord bridge failed to start (exit code: $exitCode)");
    } on TimeoutException {
      // If timeout occurred, process is still running (good!)
      DevLogger.log("‚úÖ Discord bridge is running and ready", type: LogType.startup);
    }
  }

  void _setupShutdownHandlers() {
    // Handle Ctrl+C
    ProcessSignal.sigint.watch().listen((_) async {
      if (!_isShuttingDown) {
        await _gracefulShutdown('SIGINT');
      }
    });

    // Handle SIGTERM (Unix only)
    if (!Platform.isWindows) {
      ProcessSignal.sigterm.watch().listen((_) async {
        if (!_isShuttingDown) {
          await _gracefulShutdown('SIGTERM');
        }
      });
    }
  }

  Future<void> _waitForShutdown() async {
    DevLogger.log("üõë Press Ctrl+C to safely shutdown Eden", type: LogType.startup);
    
    // Wait for shutdown signal or unexpected process death
    while (!_isShuttingDown) {
      await Future.delayed(Duration(seconds: 2));
      
      // Check if brain server died unexpectedly
      if (_promptServerProcess != null) {
        try {
          final code = await _promptServerProcess!.exitCode.timeout(Duration(milliseconds: 100));
          if (code != 0) {
            DevLogger.log("üí• Brain server crashed with code: $code", type: LogType.error);
            await _gracefulShutdown('BRAIN_CRASHED');
          } else {
            DevLogger.log("üß† Brain server exited cleanly", type: LogType.shutdown);
            await _gracefulShutdown('BRAIN_STOPPED');
          }
          break;
        } on TimeoutException {
          // Process still running, continue monitoring
        }
      }
      
      // Check if Discord bridge died unexpectedly
      if (_discordBridgeProcess != null) {
        try {
          final code = await _discordBridgeProcess!.exitCode.timeout(Duration(milliseconds: 100));
          if (code != 0) {
            DevLogger.log("üí• Discord bridge crashed with code: $code", type: LogType.error);
            await _gracefulShutdown('DISCORD_CRASHED');
          } else {
            DevLogger.log("ü§ñ Discord bridge exited cleanly", type: LogType.shutdown);
            await _gracefulShutdown('DISCORD_STOPPED');
          }
          break;
        } on TimeoutException {
          // Process still running, continue monitoring
        }
      }
    }
  }

  Future<void> _gracefulShutdown(String reason) async {
    if (_isShuttingDown) return;
    _isShuttingDown = true;

    DevLogger.log("üåô Eden system graceful shutdown initiated ($reason)...", type: LogType.shutdown);

    try {
      // Try to save Eden's state via API first
      await _saveEdenStateViaAPI();
    } catch (e) {
      DevLogger.log("‚ö†Ô∏è API state save failed, using direct save: $e", type: LogType.shutdown);
      
      // Fallback: save state directly
      try {
        await EdenStateManager.saveState(
          emotionEngine: emotionEngine,
          memoryManager: memoryManager,
          selfModel: selfModel,
          thoughtJournal: thoughtJournal,
          lastUser: "system",
          currentMood: "peaceful",
        );
      } catch (e2) {
        DevLogger.log("‚ùå Direct state save also failed: $e2", type: LogType.error);
      }
    }

    // Stop Discord bridge first (gentler)
    if (_discordBridgeProcess != null) {
      DevLogger.log("ü§ñ Stopping Discord bridge...", type: LogType.shutdown);
      _discordBridgeProcess!.kill(ProcessSignal.sigterm);
      
      try {
        await _discordBridgeProcess!.exitCode.timeout(Duration(seconds: 5));
        DevLogger.log("‚úÖ Discord bridge stopped gracefully", type: LogType.shutdown);
      } catch (e) {
        DevLogger.log("‚ö†Ô∏è Force killing Discord bridge", type: LogType.shutdown);
        _discordBridgeProcess!.kill(ProcessSignal.sigkill);
      }
    }

    // Stop brain server
    if (_promptServerProcess != null) {
      DevLogger.log("üß† Stopping Eden's brain server...", type: LogType.shutdown);
      _promptServerProcess!.kill(ProcessSignal.sigterm);
      
      try {
        await _promptServerProcess!.exitCode.timeout(Duration(seconds: 5));
        DevLogger.log("‚úÖ Eden's brain stopped gracefully", type: LogType.shutdown);
      } catch (e) {
        DevLogger.log("‚ö†Ô∏è Force killing brain server", type: LogType.shutdown);
        _promptServerProcess!.kill(ProcessSignal.sigkill);
      }
    }

    DevLogger.log("üí§ Eden system shutdown complete. She rests safely.", type: LogType.shutdown);
    exit(0);
  }

  Future<void> _saveEdenStateViaAPI() async {
    DevLogger.log("üíæ Requesting Eden to save her state...", type: LogType.shutdown);
    
    final client = HttpClient();
    try {
      final request = await client.postUrl(Uri.parse('http://localhost:4242/shutdown'));
      request.headers.set('Content-Type', 'application/json');
      request.headers.set('Connection', 'close');
      request.write('{}');
      
      final response = await request.close();
      final responseBody = await response.transform(utf8.decoder).join();
      
      if (response.statusCode == 200) {
        DevLogger.log("‚úÖ Eden saved her state via API", type: LogType.shutdown);
      } else {
        throw Exception("API returned ${response.statusCode}: $responseBody");
      }
    } finally {
      client.close();
    }
  }

  Future<void> _emergencyShutdown() async {
    DevLogger.log("üö® Emergency shutdown...", type: LogType.error);
    
    _discordBridgeProcess?.kill(ProcessSignal.sigkill);
    _promptServerProcess?.kill(ProcessSignal.sigkill);
    
    await Future.delayed(Duration(seconds: 1));
  }
}

void main() async {
  DevLogger.log("üåü Eden System Launcher starting...", type: LogType.startup);
  
  final launcher = EdenSystemLauncher();
  await launcher.startEdenSystem();
}